{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@clerk/nextjs/src/server/keyless-node.ts"],"sourcesContent":["import type { AccountlessApplication } from '@clerk/backend';\n\nimport { createClerkClientWithOptions } from './createClerkClient';\nimport { nodeCwdOrThrow, nodeFsOrThrow, nodePathOrThrow } from './fs/utils';\nimport { collectKeylessMetadata, formatMetadataHeaders } from './keyless-custom-headers';\n\n/**\n * The Clerk-specific directory name.\n */\nconst CLERK_HIDDEN = '.clerk';\n\n/**\n * The Clerk-specific lock file that is used to mitigate multiple key creation.\n * This is automatically cleaned up.\n */\nconst CLERK_LOCK = 'clerk.lock';\n\n/**\n * The `.clerk/` directory is NOT safe to be committed as it may include sensitive information about a Clerk instance.\n * It may include an instance's secret key and the secret token for claiming that instance.\n */\nfunction updateGitignore() {\n  const { existsSync, writeFileSync, readFileSync, appendFileSync } = nodeFsOrThrow();\n\n  const path = nodePathOrThrow();\n  const cwd = nodeCwdOrThrow();\n  const gitignorePath = path.join(cwd(), '.gitignore');\n  if (!existsSync(gitignorePath)) {\n    writeFileSync(gitignorePath, '');\n  }\n\n  // Check if `.clerk/` entry exists in .gitignore\n  const gitignoreContent = readFileSync(gitignorePath, 'utf-8');\n  const COMMENT = `# clerk configuration (can include secrets)`;\n  if (!gitignoreContent.includes(CLERK_HIDDEN + '/')) {\n    appendFileSync(gitignorePath, `\\n${COMMENT}\\n/${CLERK_HIDDEN}/\\n`);\n  }\n}\n\nconst generatePath = (...slugs: string[]) => {\n  const path = nodePathOrThrow();\n  const cwd = nodeCwdOrThrow();\n  return path.join(cwd(), CLERK_HIDDEN, ...slugs);\n};\n\nconst _TEMP_DIR_NAME = '.tmp';\nconst getKeylessConfigurationPath = () => generatePath(_TEMP_DIR_NAME, 'keyless.json');\nconst getKeylessReadMePath = () => generatePath(_TEMP_DIR_NAME, 'README.md');\n\nlet isCreatingFile = false;\n\nexport function safeParseClerkFile(): AccountlessApplication | undefined {\n  const { readFileSync } = nodeFsOrThrow();\n  try {\n    const CONFIG_PATH = getKeylessConfigurationPath();\n    let fileAsString;\n    try {\n      fileAsString = readFileSync(CONFIG_PATH, { encoding: 'utf-8' }) || '{}';\n    } catch {\n      fileAsString = '{}';\n    }\n    return JSON.parse(fileAsString) as AccountlessApplication;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Using both an in-memory and file system lock seems to be the most effective solution.\n */\nconst lockFileWriting = () => {\n  const { writeFileSync } = nodeFsOrThrow();\n\n  isCreatingFile = true;\n\n  writeFileSync(\n    CLERK_LOCK,\n    // In the rare case, the file persists give the developer enough context.\n    'This file can be deleted. Please delete this file and refresh your application',\n    {\n      encoding: 'utf8',\n      mode: '0777',\n      flag: 'w',\n    },\n  );\n};\n\nconst unlockFileWriting = () => {\n  const { rmSync } = nodeFsOrThrow();\n\n  try {\n    rmSync(CLERK_LOCK, { force: true, recursive: true });\n  } catch {\n    // Simply ignore if the removal of the directory/file fails\n  }\n\n  isCreatingFile = false;\n};\n\nconst isFileWritingLocked = () => {\n  const { existsSync } = nodeFsOrThrow();\n  return isCreatingFile || existsSync(CLERK_LOCK);\n};\n\nasync function createOrReadKeyless(): Promise<AccountlessApplication | null> {\n  const { writeFileSync, mkdirSync } = nodeFsOrThrow();\n\n  /**\n   * If another request is already in the process of acquiring keys return early.\n   * Using both an in-memory and file system lock seems to be the most effective solution.\n   */\n  if (isFileWritingLocked()) {\n    return null;\n  }\n\n  lockFileWriting();\n\n  const CONFIG_PATH = getKeylessConfigurationPath();\n  const README_PATH = getKeylessReadMePath();\n\n  mkdirSync(generatePath(_TEMP_DIR_NAME), { recursive: true });\n  updateGitignore();\n\n  /**\n   * When the configuration file exists, always read the keys from the file\n   */\n  const envVarsMap = safeParseClerkFile();\n  if (envVarsMap?.publishableKey && envVarsMap?.secretKey) {\n    unlockFileWriting();\n\n    return envVarsMap;\n  }\n\n  /**\n   * At this step, it is safe to create new keys and store them.\n   */\n  const client = createClerkClientWithOptions({});\n\n  // Collect metadata\n  const keylessHeaders = await collectKeylessMetadata()\n    .then(formatMetadataHeaders)\n    .catch(() => new Headers());\n\n  const accountlessApplication = await client.__experimental_accountlessApplications\n    .createAccountlessApplication({ requestHeaders: keylessHeaders })\n    .catch(() => null);\n\n  if (accountlessApplication) {\n    writeFileSync(CONFIG_PATH, JSON.stringify(accountlessApplication), {\n      encoding: 'utf8',\n      mode: '0777',\n      flag: 'w',\n    });\n\n    // TODO-KEYLESS: Add link to official documentation.\n    const README_NOTIFICATION = `\n## DO NOT COMMIT\nThis directory is auto-generated from \\`@clerk/nextjs\\` because you are running in Keyless mode. Avoid committing the \\`.clerk/\\` directory as it includes the secret key of the unclaimed instance.\n  `;\n\n    writeFileSync(README_PATH, README_NOTIFICATION, {\n      encoding: 'utf8',\n      mode: '0777',\n      flag: 'w',\n    });\n  }\n  /**\n   * Clean up locks.\n   */\n  unlockFileWriting();\n\n  return accountlessApplication;\n}\n\nfunction removeKeyless() {\n  const { rmSync } = nodeFsOrThrow();\n\n  /**\n   * If another request is already in the process of acquiring keys return early.\n   * Using both an in-memory and file system lock seems to be the most effective solution.\n   */\n  if (isFileWritingLocked()) {\n    return undefined;\n  }\n\n  lockFileWriting();\n\n  try {\n    rmSync(generatePath(), { force: true, recursive: true });\n  } catch {\n    // Simply ignore if the removal of the directory/file fails\n  }\n\n  /**\n   * Clean up locks.\n   */\n  unlockFileWriting();\n}\n\nexport { createOrReadKeyless, removeKeyless };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}